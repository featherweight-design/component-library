import { Meta, Story, Props } from '@storybook/addon-docs/blocks';

import NavigationPointer from './NavigationPointer.tsx';

<Meta
  title="Components/Navigation/NavigationPointer/README"
  component={NavigationPointer}
/>

# NavigationPointer

---

<Story id="components-navigation-navigationpointer--default" />

---

The `NavigationPointer` component allows a user to navigate through a document or form based upon a collection of "anchors" (e.g. tags, inputs, etc.) on the page. There is a robust amount of logic that attempts to accurately place the navigation pointer in the desired location, though it is not foolproof and there are likely edge cases that have not been tested.

The essence of the `NavigationPointer` depends on three crucial pieces of information:

- _Where do I live?_ (`boundingElement`)
- _What am I pointing at?_ (`anchorId`)
- _Where does the thing I'm pointer at live?_ (`targetElement`)
- _What are all of the things I can point at?_ (`anchorIdCollection`)

There are two types of keyboard controls available in this component, both of which are mounted to the `boundingElement`:

- **"Tab" and "Shift + Tab"**: These controls are **enabled** by default.
- **"Up" and "Down" arrow keys**: These controls are **disabled** by default due to the role that arrow keys often play in form elements. They can be turned on at developer discretion.

Arrow key helper hints are also available, but are **disabled** by default and must also have the `areKeyboardControlsEnabled` prop set to `true` in order to render.

This component works best when it is rendered in a larger `boundingElement` that occupies a majority of the `window` or `document.body`. Rendering the `NavigationPointer` in smaller windows or in a `boundingElement` that lives inside of a larger, scrollable container has shown some slight inconsistencies in positioning. As it currently stands, the primary use case of this component assumes a larger `boundingElement`, so this issue will not be addressed until absolutely necessary to avoid breaking existing functionality.

## Known Bugs ðŸ›

- When rendering the `NavigationPointer` inside of a scrollable `boundingElement` (parent) that sits inside of a larger scrollable element (grandparent), two primary issues will occassionally arise:
  - Slight vertical positioning inconsistencies with the primary component
  - When scrolling above or below the `NavigationPointer` the rendered position indicator will float outside of the `boundingElement` (parent) and into the larger, scrollable container (grandparent)
- Currently only one `NavigationPointer` can be rendered on the DOM at a time, due to conflicting navigation commands

## Quick Start âš¡ï¸

```scss
// MyComponent.scss

.navigation-pointer-page {
  position: relative;
  display: flex;
  flex-direction: column;
  height: 30rem;
  &__bounding-element,
  &__target-element {
    position: relative;
    display: flex;
    align-items: center;
    flex-direction: column;
  }
  &__bounding-element {
    width: 100%;
    padding: 1rem;
    border: 1px solid black;
    border-radius: 0.25rem;
    background-color: #dddbda;
    overflow-y: scroll;
  }
  &__target-element {
    justify-content: center;
    margin-bottom: 1rem;
    background-color: aquamarine;
    height: 50rem;
    width: 30rem;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.5);
  }
}
```

```jsx
// MyComponent.jsx

import React from 'react';
import { NavigationPointer } from '@one-conga/ui-components';

import './MyComponent.scss';

const MyComponent = () => {
  const [currentAnchor, updateCurrentAnchor] = useState('');
  const [isLoading, updateLoading] = useState(true);
  const boundingElement = useRef(undefined);
  const targetElement = useRef(undefined);

  useEffect(() => {
    const foundBoundingElement = document.getElementById('bounding-element');
    const foundTargetElement = document.getElementById('target-element');

    if (foundBoundingElement && foundTargetElement) {
      boundingElement.current = foundBoundingElement;
      targetElement.current = foundTargetElement;

      updateLoading(false);
    }
  }, []);

  const handleOnBack = anchorId => {
    updateCurrentAnchor(anchorId);
    console.log(`Move back to anchor ${anchorId}`);
  };
  const handleOnNext = anchorId => {
    updateCurrentAnchor(anchorId);
    console.log(`Move next to anchor ${anchorId}`);
  };

  const anchor1 = 'anchor-1';
  const anchor2 = 'anchor-2';
  const anchor3 = 'anchor-3';
  const anchor4 = 'anchor-4';
  const anchors = [anchor1, anchor2, anchor3, anchor4];

  const renderTargetElement = () => (
    <div
      id="target-element"
      className="navigation-pointer-page__target-element"
    >
      {anchors.map(anchor => (
        <div style={documentStyles}>
          <p id={anchor}>{anchor}</p>
        </div>
      ))}
    </div>
  );

  return (
    <div className="navigation-pointer-page">
      <div
        id="bounding-element"
        className="navigation-pointer-page__bounding-element"
      >
        {!isLoading && boundingElement.current && targetElement.current && (
          <NavigationPointer
            anchorId={currentAnchor}
            boundingElement={boundingElement.current}
            targetElement={targetElement.current}
            anchorIdCollection={anchors}
            onBack={handleOnBack}
            onNext={handleOnNext}
          />
        )}

        {renderTargetElement()}
      </div>
    </div>
  );
};
```

## API

### [NavigationPointer Component](https://github.com/getconga/ai-analyze/blob/develop/Apps/ui-components/src/components/Navigation/NavigationPointer/NavigationPointer.tsx)

<Props of={NavigationPointer} />
